#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<time.h>
#include <windows.h>
#include <conio.h>

#define SIZE 10 //정점개수

#define MAPCOL 71//맵크기
#define MAPROW 20 //맵크기

#define ROOMCOL 30//맵크기
#define ROOMROW 20 //맵크기

#define MAX 10000
#define INF 1000
#define FALSE 0
#define TRUE 1

#define UP_KEY 72
#define DOWN_KEY 80
#define LEFT_KEY 75
#define RIGHT_KEY 77
#define SELECT_KEY 13

#define UP 72
#define DOWN 80
#define LEFT 75
#define RIGHT 77
#define SELECT 13

//색상
enum {
    BLACK,
    DARK_BLUE,
    DARK_GREEN,
    DARK_SKYBLUE,
    DARK_RED,
    DARK_VOILET,
    DAKR_YELLOW,
    GRAY,
    DARK_GRAY,
    BLUE,
    GREEN,
    SKYBLUE,
    RED,
    VIOLET,
    YELLOW,
    WHITE,
};

//좌표 구조체
typedef struct Point {
    int x;
    int y;
}Point;

//플레이어 위치 스택으로 저장
typedef struct PlayerPoint {
    int life;
    int cur_vertex;//현재 정점
    int rear;
    int front;
    int can_move[SIZE];//이동가능한 정점이 인덱스 1 : 이동가능, 0 : 이동불가능
}PlayerPoint;

//save노드
typedef struct SaveNode {
    int cost;
    int vertex;
    int life;
    struct Point room_point;
    struct SaveNode* next;
}SaveNode;

//save리스트
typedef struct SaveList {
    int count;
    SaveNode* next;
    SaveNode* last;
}SaveList;

//각 정점의 좌표들 [idx]가 정점번호
typedef struct VertexPoint {
    Point vertex_point[SIZE];
}VertexPoint;

//다익스트라에 사용되는 노드
typedef struct HeapNode {
    int vertex;
    int distance;
}HeapNode;

typedef struct HeapType {
    int heap_size;
    HeapNode* node[SIZE + 1];
}HeapType;

//전역변수들
int distance[SIZE] = { 0, }; //시작 정점에서 각 정점으로 이동하는 최단거리 
int found[SIZE] = { 0, };; //방문한 정점은 TRUE, 아직 방문하지 않은 정점은 FALSE
int arr[SIZE] = { 0, };;//현재위치에서 이동가능한 정점확인 TRUE : 이동가능, FALSE : 이동불가능
int print_arr[SIZE][SIZE] = { FALSE, };

int cost = 0; // 도착점까지 사용할 비용 이동 시 가중치만큼 사용
int start = 0; // 플레이어 위치
int finish = SIZE - 1; // 도착점

//Player
Point room_player = { 1, 18 };   //player 시작 좌표 
Point previous_room_player = { 1, 18 };   //player 방 시작 좌표 
Point life_bar = { 0, 22 }; //life 출력 좌표

//글자 출력 위치
Point text_pos = { 0, 23 };

int keyinput_main_menu();
int keyinput();

void infomenu() { //게임 설명창 출력 함수

    system("cls");

    printf("숫자를 입력하여 가장 짧게 가세요 어쩌구 저쩌구 ");

    while (1) {

        if (keyinput_main_menu() == SELECT) {
            break;
        }
    }
}

void init() { //콘솔 초기화
    system("mode con cols=70 lines=30");

    HANDLE consolHandle = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_CURSOR_INFO ConsoleCursor;
    ConsoleCursor.bVisible = 0;
    ConsoleCursor.dwSize = 1;
    SetConsoleCursorInfo(consolHandle, &ConsoleCursor);

}

// 커서 이동
void gotoxy(int x, int y) {

    HANDLE consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);
    COORD pos;
    pos.X = x * 2;
    pos.Y = y;

    SetConsoleCursorPosition(consoleHandle, pos);
}


int menudraw() { //메인 메뉴 선택창 출력 함수

    int x = 25;
    int y = 15;


    gotoxy(x - 1, y);
    printf("> 게임 시작");
    gotoxy(x, y + 1);
    printf("게임 방법");
    gotoxy(x, y + 2);
    printf("종료");

    while (1) {

        int k = keyinput();

        switch (k) {

        case UP: {
            if (y > 15)
            {
                gotoxy(x - 1, y);
                printf(" ");
                gotoxy(x - 1, --y);
                printf(">");
            }
            break;
        }
        case DOWN: {
            if (y < 17)
            {
                gotoxy(x - 1, y);
                printf(" ");
                gotoxy(x - 1, ++y);
                printf(">");
            }
            break;
        }
        case SELECT: {
            return y - 15;
        }
        }
    }
}

int keyinput() {

    char c;

    while (1)
    {
        if (_kbhit())
        {
            c = _getch();

            if (c == SELECT_KEY)
            {
                return SELECT;
            }
            else if (c == -32)
            {
                c = _getch();

                switch (c) {
                case UP_KEY:
                    return UP;
                    break;
                case DOWN_KEY:
                    return DOWN;
                    break;
                case LEFT_KEY:
                    return LEFT;
                    break;
                case RIGHT_KEY:
                    return RIGHT;
                    break;
                }
            }
        }
    }
}



void titledraw() { //타이틀 화면 출력 함수

    printf("\n\n\n\n");
    printf("      ###    ###        #####        #######       ####### \n");
    printf("      ## #  # ##      ###   ###          ##        ###     \n");
    printf("      ##  ##  ##      #########        ###         ####### \n");
    printf("      ##  ##  ##      ##     ##       ##           ###     \n");
    printf("      ##      ##      ###   ###      ########      ####### \n");
}


//각 정점 가중치
int weight[SIZE][SIZE] = {
   {0,2,4,INF,INF,INF,INF,INF,INF,INF},
{2,0,INF,1,INF,INF,2,INF,INF,INF},
{4,INF,0,INF,2,INF,INF,INF,INF,INF},
{INF,1,INF,0,INF,2,4,INF,INF,INF},
{INF,INF,2,INF,0,3,2,INF,INF,INF},
{INF,INF,INF,2,3,0,1,3,INF,INF},
{INF,2,INF,4,2,1,0,INF,3,INF},
{INF,INF,INF,INF,INF,3,INF,0,1,2},
{INF,INF,INF,INF,INF,INF,3,1,0,INF},
{INF,INF,INF,INF,INF,INF,INF,1,INF,0}
};

int room[SIZE][ROOMROW][ROOMCOL] = {
    //0번방A
    {{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
 {1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 1, 0, 1, 1, 0, 1, 0, 3, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 1},
 {1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 1},
 {1, 0, 1, 1, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1},
 {1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 'S', 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 3, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1},
 {1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 1},
 {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1},
 {1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 'C'},
 {1, 0, 1, 3, 1, 3, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1},
 {1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1},
 {1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 1},
 {1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 1},
 {1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 3, 0, 0, 3, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1},
 {1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'B', 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}},

 //1번방B
 {{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'A', 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 3, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'D'},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 3, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 1},
 {1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 3, 0, 3, 1},
 {1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 1},
 {1, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 1},
 {1, 3, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 3, 1},
 {1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 'S', 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'G', 1, 1}},

 //2번방C
 {{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'S', 1},
 {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
 {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1},
 {'A', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1},
 {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1},
 {1, 0, 0, 1, 0, 0, 0, 3, 3, 3, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1},
 {1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
 {1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'E', 1, 1, 1, 1, 1, 1}},

 //3번방D
  {{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 1, 0, 0, 0, 1},
 {'B', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 3, 0, 0, 1, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 0, 0, 1},
 {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 1},
 {1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 'F'},
 {1, 0, 0, 0, 1, 'S', 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 1},
 {1, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1},
 {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1},
 {1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 1},
 {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'G', 1, 1, 1, 1, 1, 1, 1}},


 //4번방E
 {{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'C', 1, 1, 1, 1, 1, 1},
 {1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 3, 3, 1},
 {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
 {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 3, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 'F'},
 {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1},
 {1, 0, 0, 1, 0, 1, 0, 3, 3, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 1},
 {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 3, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 'S', 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'G', 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}},

 //5번방F
 { {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1, 1, 1, 1, 1},
 {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 'H'},
 {'E', 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 'S', 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'G', 1, 1, 1, 1, 1, 1, 1, 1, 1, 1} },

 //6번방G
 { {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'E', 1, 1, 1, 'F', 1, 1, 1, 1, 1, 1, 1, 'D', 1, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 3, 0, 1, 1, 1, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
 {1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 'I'},
 {1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 1},
 {1, 0, 0, 0, 'S', 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1},
 {1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1} },

 //7번방H
 { {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
 {1, 0, 0, 1, 3, 0, 0, 0, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 0, 0, 3, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1},
 {1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 1, 'S', 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1},
 {'F', 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 3, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'J'},
 {1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 3, 1, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'I', 1, 1, 1, 1, 1, 1, 1, 1, 1, 1} },

 //8번방I
 { {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'H', 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 0, 3, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1},
 {1, 0, 0, 0, 1, 0, 0, 3, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 1, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 1, 0, 3, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1},
 {'G', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1},
 {1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1},
 {1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
 {1, 0, 0, 0, 0, 1, 0, 1, 'S', 1, 0, 0, 3, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 3, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1} },

 //9번방J
 { {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1},
 {'H', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1},
 {1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
 {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1} }
};

//벽 : 1, 공백 : 0, 2 : 통로, A~J : 정점
//벽 : 1, 공백 : 0, 2 : 통로, A~J : 정점
char map[MAPROW][MAPCOL] = {
   {"1111111111111111111111111111111111111111111111111111111111111111111111"},
   {"1000000000000000000000000000000000000000000000000000000000000000000001"},
   {"1000333330000000333330000000000000000000000000000000000000000000000001"},
   {"100030A03222e22230C030000000000000000000000000000000333330000000000001"},
   {"100033333000000033333000000333330000000000000000022230H032222222200001"},
   {"10000020000000000020000222230D0322222c22222000000200333330000000200001"},
   {"1000002000002222b22222200003333300000000002000000200002000000000200001"},
   {"100000c000002000002000000000020000000000002000000d000022B2220000200001"},
   {"10000020003333300020000000000e0000000000333330000200000000020000200001"},
   {"100000222230B03000c00000000002222200022230F032222200000003333300c00001"},
   {"10000000003333300020000033333000020002003333300000000000030I0300200001"},
   {"10000000000020000022222230E032222d222200002000000000000003333300200001"},
   {"100000000000200000000000333330000200000000b000000000000000020000200001"},
   {"10000000000020000000000000200000020000000020000222d2222222220000200001"},
   {"1000000000002000000000000020000002000000333330020000000000000000200001"},
   {"10000000000020000000000000c222222222222230G032220033333000000000200001"},
   {"1000000000002000000000000000000000000000333330000030J03222222222200001"},
   {"100000000000c222222222222222222222222222222000000033333000000000000001"},
   {"1000000000000000000000000000000000000000000000000000000000000000000001"},
   {"1111111111111111111111111111111111111111111111111111111111111111111111"}
};




//함수들
void setColor(unsigned short text);

//다익스트라(최단거리 구하는 함수)
int choose(int distance[], int n, int found[]);
void Shortest_Path_Dijkstra(int start, int n);


//이동할 정점 입력받는 함수
void input_move(PlayerPoint* player, VertexPoint* vertex);
//이동할 정점 선택하는 함수
int choose_vertex(PlayerPoint* player, VertexPoint* vertex);

//정점들 좌표 저장하는 함수
void set_vertex(VertexPoint* vertex);
//플레이어 이동 가능한 좌표 확인하는 함수
void check_move_vertex(PlayerPoint* player, VertexPoint* vertex);

//맵출력
void print_map(PlayerPoint* player, VertexPoint* vertex);

//라이프
void life_output(PlayerPoint* player);//라이프 출력
void minus_life(PlayerPoint* player);//라이프 감소

//세이브
SaveNode* init_save_node(PlayerPoint* player, int save_vertex, int save_cost, Point save_room_point);//초기화
SaveList* insert_save(SaveList* save_root, SaveNode* node);//추가
void del_save(SaveList* save_root, SaveNode* node, SaveNode* pre_node);//지우기

// 콘솔 텍스트 색상 변경해주는 함수
void setColor(unsigned short text) {
    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), text);
}



/*###################################################################

   heap관련 함수

 ###################################################################*/
 //초기화 함수
void init_heap(HeapType* h) {
    for (int i = 0; i <= SIZE; i++) {
        h->node[i] = (HeapNode*)malloc(sizeof(HeapNode));
    }
    h->heap_size = 0;
}

//추가 함수
void insert_node(HeapType* h, HeapNode* input) {
    if (input->distance == INF || input->distance == 0) {
        return;
    }
    h->heap_size++;
    int num = h->heap_size;

    while (num > 1) {
        if (input->distance < h->node[num / 2]->distance) {
            h->node[num]->distance = h->node[num / 2]->distance;
            h->node[num]->vertex = h->node[num / 2]->vertex;
            num /= 2;
        }
        else {
            break;
        }
    }
    h->node[num]->distance = input->distance;
    h->node[num]->vertex = input->vertex;
}

//삭제 함수
int delete_node(HeapType* h) {
    int re_num = h->node[1]->vertex;
    HeapNode* tmp = h->node[h->heap_size];
    h->heap_size--;

    int num = 2;

    while (num <= h->heap_size) {
        if (h->node[num]->distance > h->node[num + 1]->distance) {
            num++;
        }
        if (tmp->distance < h->node[num]->distance) {
            h->node[num / 2]->distance = h->node[num]->distance;
            h->node[num / 2]->vertex = h->node[num]->vertex;
            num *= 2;
        }
        else {
            break;
        }
    }
    h->node[num / 2]->distance = tmp->distance;
    h->node[num / 2]->vertex = tmp->vertex;
    return re_num;
}


/*###################################################################

   목적 :시작 정점과의 거리가 가장 짧은 정점을 반환

   입력
      1. distance[] : 각 정점으로 이동하는 최단거리를 저장하는 배열
      2. n : 정점 개수
      3. fountp[] : 방문한 정점을 확인하는 배열

   출력
      1. min_pos : 가장 짧은 정점 반환
 ###################################################################*/
int choose(int distance[], int n, int found[]) {
    int min = MAX;
    int min_pos = -1;
    for (int i = 0; i < n; i++) {
        if (found[i] == FALSE && min > distance[i]) {
            //아직 방문하지않은 곳 중 최소거리 구하기
            min = distance[i];
            min_pos = i;
        }
    }

    return min_pos;

}

/*###################################################################

   목적 : 시작 정점으로부터 그래프 내의 모든 정점에 대한 최단 경로 구하기.

   입력
      1. start : 시작 정점
      2. n : 정점 개수

   출력
      1. distance[idx] 배열에 각 정점(idx)로 이동하는 최단거리가 저장

###################################################################*/
void Shortest_Path_Dijkstra(int start, int n) {
    //min_heap 생성
    HeapType* min_heap = (HeapType*)malloc(sizeof(HeapType));
    HeapNode* tmp = (HeapNode*)malloc(sizeof(HeapNode));
    init_heap(min_heap); //초기화
    int u = 0;
    //시작 정점으로부터 그래프 내의 모든 정점에 대한 최단 경로를 구함.
    for (int i = 0; i < n; i++) {
        distance[i] = weight[start][i];
        tmp->distance = distance[i];
        tmp->vertex = i;
        insert_node(min_heap, tmp);//heap에다 노드 추가
        found[i] = FALSE;
    }
    found[start] = TRUE;

    for (int i = 0; i < n - 1; i++) {
        u = delete_node(min_heap);//하나 뽑으면 최솟값
        //u = choose(distance, n, found);
        found[u] = TRUE;

        for (int j = 0; j < n; j++) {
            if (found[j] == FALSE && distance[u] + weight[u][j] < distance[j]) {
                distance[j] = distance[u] + weight[u][j];
                tmp->distance = distance[j];
                tmp->vertex = j;
                insert_node(min_heap, tmp);//새로 업데이트 된 노드 insert
            }

        }

    }
}





/*###################################################################

   목적 : 현재 위치 정점에서 이동가능한 정점을 구함

   입력값
      1.   현재 위치 정점
      2.  정점들 좌표

   출력값
      1.   이동 가능한 정점들
      -> player->can_move 업데이트

###################################################################*/
void check_move_vertex(PlayerPoint* player, VertexPoint* vertex) {
    for (int i = 0; i < SIZE; i++) {
        player->can_move[i] = FALSE;
        if (weight[player->cur_vertex][i] != INF && player->cur_vertex != i) {
            player->can_move[i] = TRUE;
        }
    }
}


/*###################################################################

   목적 : 세이브 리스트 출력

###################################################################*/
void print_deque(PlayerPoint* player) {
    //세이브 리스트 출력하기
}


//위, 아래 키 입력
int keyinput_main_menu() {

    char c;

    while (1)
    {
        if (_kbhit())
        {
            c = _getch();

            if (c == SELECT_KEY)
            {
                return SELECT;
            }
            else if (c == -32)
            {
                c = _getch();

                switch (c) {
                case UP_KEY:
                    return UP_KEY;
                    break;
                case DOWN_KEY:
                    return DOWN_KEY;
                    break;
                }
            }
        }
    }
}


/*###################################################################

   목적 : 이동가능한 정점 선택지로 보여주기

   선택한 정점 반환하기

###################################################################
int choose_vertex(PlayerPoint* player, VertexPoint* vertex) {

   int arr[SIZE+1] = {0,};

   //변하는 커서 값
   int x = 0;
   int y = 0;

   //초기 커서 값
   int print_vertex_x = 0;
   int print_vertex_y = MAPROW + 2;
   int count = 0;
   gotoxy(print_vertex_x, print_vertex_y);
   printf("------------------------------------");
   gotoxy(print_vertex_x++, print_vertex_y++);
   for (int i = 0; i < SIZE; i++) {
      if (player->can_move[i]) {
         gotoxy(print_vertex_x, print_vertex_y++);
         printf("%d점으로 이동한다.(비용 : %d)", i, weight[player->cur_vertex][i]);
         arr[count] = i;//선택지 vertex값을 저장해둔다.
         count++;
      }
   }

   if (!deque_is_empty(player)) {
      gotoxy(print_vertex_x, print_vertex_y++);
      arr[count] = MAX;//선택지 vertex값을 저장해둔다.
      printf("이전 위치(%d)로 돌아간다.(비용 : %d)", player->player_point[player->rear].stack_vertex, player->player_point[player->rear].pre_cost);
   }
   gotoxy(print_vertex_x--, print_vertex_y++);
   printf("------------------------------------\n");
   print_deque(player);


   //첫 번째 선택지로
   int print_choose_x = 0;
   int print_choose_y = MAPROW + 3;
   x = print_choose_x;
   y = print_choose_y;
   gotoxy(x, y);
   printf(">");
   while (1) {
      int k = keyinput();

      switch (k) {

      case UP: {
         if (print_choose_y < y && y <= print_choose_y + count)
         {
            gotoxy(x, y);
            printf(" ");
            gotoxy(x, --y);
            printf(">");
         }
         break;
      }
      case DOWN: {
         if (!deque_is_empty(player)) {
            //스택에 값이 있으면 스택까지 선택지 추가
            if (print_choose_y <= y && y < print_choose_y + count)
            {
               gotoxy(x, y);
               printf(" ");
               gotoxy(x, ++y);
               printf(">");
            }
         }
         else {
            //스택이 없을 때
            if (print_choose_y <= y && y < print_choose_y + count-1)
            {
               gotoxy(x, y);
               printf(" ");
               gotoxy(x, ++y);
               printf(">");
            }
         }
         break;
      }
      case SELECT: {
         return arr[y-print_choose_y];
      }
      }
   }

}
*/

/*###################################################################

   목적 : 세이브 리스트에 세이브 추가하기

###################################################################*/

void push_move(PlayerPoint* player, int vertex, int cost) {
    //세이브 리스트에 마지막에 추가
}

void fatal()
{
}


void input_move(PlayerPoint* player, VertexPoint* vertex, int move_point) {

    /*
    printf("어디로 이동하겠습니까?( ");
    for (int i = 0; i < SIZE; i++) {
       if (player->can_move[i] == TRUE) {
          printf("%d:%d  ", i, weight[player->cur_vertex][i]);
       }
    }
    printf(" 이전 위치로 : 9)\n");
    */
    //방에서 다른 방으로 이동할 때 기존 방 저장
    int pre_pos = player->cur_vertex;

    /*이전 위치로?
    pos = choose_vertex(player, vertex);
    if (player->cur == MAX && player->rear >= 0) {
       DequePoint pre_point = pop_move(player);
       cost = pre_point.pre_cost;
       player->cur_vertex = pre_point.stack_vertex;
    }*/
    //이동 할 방 체크
    if (SIZE > move_point && move_point >= 0) {
        //이동 할 방이 가능하다면?
        if (player->can_move[move_point] == TRUE) {
            //이전 위치, 코스트 저장해두기
            push_move(player, pre_pos, cost);
            //현재위치 갱신
            player->cur_vertex = move_point;
            if (weight[pre_pos][move_point] == INF) {
                printf("잘못된 접근입니다.");
            }
            else {
                cost -= weight[pre_pos][move_point];
            }
        }
    }
}

/*###################################################################

   목적 : 정점좌표 저장하기

   vertex->vertex_point[정점번호] = 정점좌표

###################################################################*/
void set_vertex(VertexPoint* vertex) {
    for (int i = 0; i < MAPROW; i++) {
        for (int j = 0; j < MAPCOL; j++) {
            switch (map[i][j])
            {
            case 0: break;
            case 1: break;
            case 2: break;
            default:
                vertex->vertex_point[map[i][j] - 'A'].x = j;
                vertex->vertex_point[map[i][j] - 'A'].y = i;
            }
        }
    }
}


/*###################################################################

   목적 : 맵 출력

   player 정점 빨간색 표시
   현재 정점 기준 이동가능한 정점 초록색을 표시


###################################################################*/
void print_map(PlayerPoint* player, VertexPoint* vertex) {
    gotoxy(0, 0);
    Point point = vertex->vertex_point[player->cur_vertex];

    int vertex_num = 0;

    int x[SIZE] = { 0, };//이동가능한 정점의 x좌표
    int y[SIZE] = { 0, };//이동가능한 정점의 y좌표
    for (int i = 0; i < SIZE; i++) {
        //-1인 경우 이동이 불가능한 정점
        x[i] = -1;
        y[i] = -1;
        if (player->can_move[i] == TRUE) {
            //이동가능한 정점(i)번째 인덱스에 x,y값을 
            x[i] = vertex->vertex_point[i].x;
            y[i] = vertex->vertex_point[i].y;
        }
    }

    for (int i = 0; i < MAPROW; i++) {
        for (int j = 0; j < MAPCOL - 1; j++) {
            vertex_num = map[i][j] - 1;
            //player위치일 경우(빨간색)
            if ((point.x - 2 <= j && j <= point.x + 2) && (point.y - 1 <= i && i <= point.y + 1)) {
                setColor(RED);
            }
            else {
                setColor(GRAY);
            }
            //이동가능한 정점인 경우(초록색)
            for (int k = 0; k < SIZE; k++) {
                if (x[k] != -1 && y[k] != -1) {
                    if ((x[k] - 2 <= j && j <= x[k] + 2) && (y[k] - 1 <= i && i <= y[k] + 1)) {
                        setColor(GREEN);
                    }
                }
            }

            switch (map[i][j])
            {
            case '0': printf(" "); break;
            case '2': printf("#"); break;
            case '3': printf("*"); break;
            case '1': printf("@"); break;
            default:
                if ('a' <= map[i][j] && map[i][j] <= 'z') {
                    setColor(VIOLET);
                    printf("%d", map[i][j] - 'a');
                    setColor(GRAY);
                }
                if ('A' <= map[i][j] && map[i][j] <= 'Z') {
                    if ('J' == map[i][j]) {
                        setColor(BLUE);
                        printf("F");
                        setColor(GRAY);
                    }
                    else {
                        printf("%d", (map[i][j]) - 'A');
                    }
                }
            }
        }
        printf("\n");
    }

}

void init_player_point(PlayerPoint* player) {
    player->cur_vertex = start;
    player->life = 3;
    player->front = 0;
    player->rear = 0;
}

void print_room(PlayerPoint* player, VertexPoint* vertex) {
    check_move_vertex(player, vertex);
    gotoxy(0, 0);
    for (int i = 0; i < ROOMROW; i++) {
        for (int j = 0; j < ROOMCOL; j++) {
            switch (room[player->cur_vertex][i][j])
            {
            case 1: printf("■"); break;
            case 0: printf("　"); break;
            case 3:
                setColor(RED);
                printf("ⓧ");
                setColor(GRAY);
                break;
            case 'S':
                setColor(GREEN);
                printf("S ");
                setColor(GRAY);
                break;
            default:
                printf("◈");
                break;
            }
        }
        printf("\n");
    }
    printf("room : %d\n", player->cur_vertex);
    printf("cost : %d\n", cost);
    life_output(player);
}


void playermove_event(SaveList* save_root, PlayerPoint* player, VertexPoint* vertex, int input) {
    int up = 0, down = 0, left = 0, right = 0;
    switch (input) {
    case UP_KEY:
        up++;
        break;
    case DOWN_KEY:
        down++;
        break;
    case LEFT_KEY:
        left++;
        break;
    case RIGHT_KEY:
        right++;
    }
    int move_point = room[player->cur_vertex][room_player.y + down - up][room_player.x + right - left];
    //빈공간 이동
    if (move_point == 0) {
        room_player.x = room_player.x + right - left;
        room_player.y = room_player.y + down - up;
        gotoxy(previous_room_player.x, previous_room_player.y); printf("  ");
        return;
    }
    //함정
    else if (move_point == 3) {
        room_player.x = room_player.x + right - left;
        room_player.y = room_player.y + down - up;
        room[player->cur_vertex][room_player.y][room_player.x] = 0;
        gotoxy(previous_room_player.x, previous_room_player.y); printf("  ");
        minus_life(player);
        return;
    }
    //세이브포인트
    else if (move_point == 'S') {
        room_player.x = room_player.x + right - left;
        room_player.y = room_player.y + down - up;
        room[player->cur_vertex][room_player.y][room_player.x] = 0;
        gotoxy(previous_room_player.x, previous_room_player.y); printf("  ");
        //세이브 노드 추가
        save_root = insert_save(save_root, init_save_node(player, player->cur_vertex, cost, room_player));
    }
    //다른 방으로 이동
    else if ('A' <= move_point && move_point <= 'A' + SIZE) {
        //통로로 이동
        room_player.x = room_player.x + right - left;
        room_player.y = room_player.y + down - up;
        system("cls");
        gotoxy(previous_room_player.x, previous_room_player.y); printf("  ");
        input_move(player, vertex, move_point - 'A');
        print_room(player, vertex);
        room_player.x = room_player.x - right * 28 + left * 28;
        room_player.y = room_player.y - down * 18 + up * 18;
        //통로의 한 칸 전으로 이동
    }
    else return;
}

void life_output(PlayerPoint* player)      //생명력 출력 
{
    gotoxy(life_bar.x, life_bar.y);
    for (int i = 0; i < player->life; i++) {//전역 변수life의 값만큼 출력 
        printf("♥");
    }
}

void minus_life(PlayerPoint* player) {
    player->life--;
    gotoxy(player->life, life_bar.y);
    printf("　");
}

void del_save(SaveList* save_root, SaveNode* node, SaveNode* pre_node) {

    //세이브 파일이 하나일 때
    if (save_root->last == save_root->next) {
        save_root->last = save_root->next = NULL;
    }
    //첫 번쨰 파일 빼오는 경우
    else if (save_root->next == node) {
        //첫 번째 파일 업데이트
        save_root->next = node->next;
        free(node);
    }
    //마지막 파일일 때
    else if (save_root->last == node) {
        //마지막 파일 업데이트
        save_root->last = pre_node;
        free(node);
    }
    //중간에서 하나 빼오는 경우
    else {
        //이전 노드랑 현재 노드 다음 연결
        pre_node->next = node->next;
        free(node);
    }
    save_root->count--;
}

void call_save(SaveList* save_root, PlayerPoint* player, int num) {
    SaveNode* tmp = save_root->next;
    SaveNode* pre_tmp = NULL;

    //세이브 번호까지 반복해서 찾기
    for (int i = 0; i < num; i++) {
        if (tmp == tmp->next == NULL) break;
        pre_tmp = tmp;
        tmp = tmp->next;
    };

    player->cur_vertex = tmp->vertex;
    player->life = tmp->life;
    room_player = tmp->room_point;
    cost = tmp->cost;

    del_save(save_root, tmp, pre_tmp);

}

void choose_save(SaveList* save_root, PlayerPoint* player) {
    //세이브가 없을 경우
    if (save_root->next == NULL) {
        return;
    }

    //초기 커서 값
    int x = text_pos.x;
    int y = text_pos.y;

    int back_choose = FALSE;
    int pick_save = FALSE;

    //선택지 개수( 취소 포함 )
    int count = save_root->count + 1;
    gotoxy(x, y);
    //첫 번째 선택지로;
    printf(">");
    while (1) {
        int k = keyinput();

        switch (k) {
        case UP_KEY:
            if (text_pos.y < y && y <= text_pos.y + count)
            {
                gotoxy(x, y);
                printf(" ");
                gotoxy(x, --y);
                printf(">");
            }
            break;

        case DOWN_KEY:
            //스택에 값이 있으면 스택까지 선택지 추가
            if (text_pos.y <= y && y < text_pos.y + count - 1)
            {
                gotoxy(x, y);
                printf(" ");
                gotoxy(x, ++y);
                printf(">");
            }
            break;

            //골랐을 때
        case SELECT:
            //취소일 때
            if (y == text_pos.y + count - 1) {
                back_choose = TRUE;
                break;
            }
            //세이브일 때
            else {
                call_save(save_root, player, y - text_pos.y);
                pick_save = TRUE;
                break;
            }
        }

        if (back_choose == TRUE || pick_save == TRUE) {
            break;
        }
    }

}

void text_clear(SaveList* save_root) {
    gotoxy(text_pos.x, text_pos.y);
    int count = save_root->count; //세이브 개수
    for (int i = 0; i <= save_root->count; i++) {
        printf("                                                \n");
    }
    printf("                                                \n");//취소(1)
    printf("                                                \n");//없을 때 지우기(1)
}

void print_save(SaveList* save_root) {
    //세이브가 비어있는 경우
    gotoxy(text_pos.x, text_pos.y);
    int i = 1;
    if (save_root->next == NULL) {
        printf("세이브가 없습니다,\n");
        Sleep(500);
    }
    else {
        for (SaveNode* tmp = save_root->next; tmp; tmp = tmp->next) {
            printf(" %d번 세이브(방 : %d, cost : %d, life : %d)\n", i, tmp->vertex, tmp->cost, tmp->life);
            i++;
        }
        printf(" 취소                                                            \n");
    }
}

void use_save(SaveList* save_root, PlayerPoint* player) {
    print_save(save_root);
    choose_save(save_root, player);
    text_clear(save_root);
}

SaveNode* init_save_node(PlayerPoint* player, int save_vertex, int save_cost, Point save_room_point) {
    SaveNode* node = (SaveNode*)malloc(sizeof(SaveNode));
    node->cost = save_cost;
    node->life = player->life;
    node->room_point = save_room_point;
    node->vertex = save_vertex;
    node->next = NULL;
    return node;
}

void init_save_root(SaveList* save_root) {
    save_root->count = 0;
    save_root->last = NULL;
    save_root->next = NULL;
}

SaveList* insert_save(SaveList* save_root, SaveNode* node) {
    //세이브가 없는 경우
    if (save_root->next == NULL) {
        save_root->next = node;
        save_root->last = node;
    }
    else {
        save_root->last->next = node;
        save_root->last = node;
    }
    save_root->count++;
    return save_root;
}

void gamestart() {

    VertexPoint* vertex_point = (VertexPoint*)malloc(sizeof(VertexPoint));//정점들의 좌표값을 가지고 있음
    PlayerPoint* player_point = (PlayerPoint*)malloc(sizeof(PlayerPoint));//플레이어
    SaveList* save_root = (SaveList*)malloc(sizeof(SaveList));//세이브
    init_player_point(player_point);
    init_save_root(save_root);

    //시작점에서 도착점으로 가는 최단거리 비용으로 설정
    Shortest_Path_Dijkstra(0, SIZE);
    cost = distance[finish]+5;


    //정점좌표 저장하기

    set_vertex(vertex_point);
    //현재 위치 저장하기
    if (player_point != NULL) {
        player_point->cur_vertex = start;
    }
    else {
        printf("player_point 가 NULL입니다.");
    }

    //이동가능한 정점 확인
    print_room(player_point, vertex_point);
    gotoxy(1, 18);
    printf("⊙");

    int key = 0;
    while (TRUE) {
        if (player_point == NULL) {
            printf("플레이어 포인터가 없습니다.\n");
            return;
        }
        if (_kbhit())
        {
            previous_room_player.x = room_player.x;
            previous_room_player.y = room_player.y;
            key = _getch();
            switch (key)
            {
            case UP_KEY:
                playermove_event(save_root, player_point, vertex_point, UP_KEY);
                break;
            case LEFT_KEY:
                playermove_event(save_root, player_point, vertex_point, LEFT_KEY);
                break;
            case DOWN_KEY:
                playermove_event(save_root, player_point, vertex_point, DOWN_KEY);
                break;
            case RIGHT_KEY:
                playermove_event(save_root, player_point, vertex_point, RIGHT_KEY);
                break;
                //맵 열기
            case 'm':
                //이동가능한 정점 확인
                check_move_vertex(player_point, vertex_point);
                //맵출력(플레이어 위치색깔 변화, 이동 가능한 위치 색깔 변화)
                print_map(player_point, vertex_point);
                Sleep(2000);
                system("cls");
                print_room(player_point, vertex_point);
                break;
                //세이브 열기
            case 's':
                use_save(save_root, player_point);
                print_room(player_point, vertex_point);
                //이동가능한 정점 확인
                check_move_vertex(player_point, vertex_point);
            }
            gotoxy(room_player.x, room_player.y);
            printf("⊙");
        }
        if (player_point->life == 0) {
            system("cls");
            printf("\n\n\n\n");
            printf("                #######   #####   ###    ###  ####### \n");
            printf("                ##       ##   ##  # ##  ## #  ##      \n");
            printf("                ##  ###  #######  #   ##   #  ####### \n");
            printf("                ##    #  ##   ##  #   ##   #  ##      \n");
            printf("                #######  ##   ##  #        #  ####### \n\n");
            printf("                #######  ##   ##  #######  #########  \n");
            printf("                ##   ##  ##   ##  ##       ###     ## \n");
            printf("                ##   ##  ##   ##  #######  #########  \n");
            printf("                ##   ##  ### ###  ##       ## ####    \n");
            printf("                #######    ###    #######  ##    #### \n");
            Sleep(5000);
            break;
        }
        if (player_point->cur_vertex == finish && cost >= 0) {
            system("cls");
            printf("\n\n\n\n");
            printf("                #######   #####   ###    ###  ####### \n");
            printf("                ##       ##   ##  # ##  ## #  ##      \n");
            printf("                ##  ###  #######  #   ##   #  ####### \n");
            printf("                ##    #  ##   ##  #   ##   #  ##      \n");
            printf("                #######  ##   ##  #        #  ####### \n\n");
            printf("             #######  ##       #######   #####   #########  \n");
            printf("             ##       ##       ##       ##   ##  ###     ## \n");
            printf("             ##       ##       #######  #######  #########  \n");
            printf("             ##       ##       ##       ##   ##  ## ####    \n");
            printf("             #######  #######  #######  ##   ##  ##    #### \n");
            printf("                              남은 비용 : %d\n", cost);
            Sleep(5000);
            break;
        }
        else if (cost < 0) {
            system("cls");
            printf("\n\n\n\n");
            printf("                #######   #####   ###    ###  ####### \n");
            printf("                ##       ##   ##  # ##  ## #  ##      \n");
            printf("                ##  ###  #######  #   ##   #  ####### \n");
            printf("                ##    #  ##   ##  #   ##   #  ##      \n");
            printf("                #######  ##   ##  #        #  ####### \n\n");
            printf("                #######  ##   ##  #######  #########  \n");
            printf("                ##   ##  ##   ##  ##       ###     ## \n");
            printf("                ##   ##  ##   ##  #######  #########  \n");
            printf("                ##   ##  ### ###  ##       ## ####    \n");
            printf("                #######    ###    #######  ##    #### \n");
            printf("                         남은 비용이 없습니다.        \n");
            Sleep(5000);
            break;
        }
    }

    free(save_root);
    free(player_point);
    free(vertex_point);
    return;
}

int main()
{
    init();


    while (1) {

        titledraw();

        int menucode = menudraw();

        if (menucode == 0) // 게임 시작
        {
            //게임 시작
            gamestart();
        }
        else if (menucode == 1) // 설명 시작
        {
            infomenu();
        }
        else if (menucode == 2)
        {
            return 0;
        }

        system("cls");

    }
    return 0;
}